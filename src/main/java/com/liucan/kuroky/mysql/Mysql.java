package com.liucan.kuroky.mysql;

/**
 * @author liucan
 * @date 5/22/21
 */
public interface Mysql {
    /**
     *
     *  22.主键，外建，主表，从表
     *      参考：https://blog.csdn.net/WICHER_WU/article/details/80263486
     *          https://www.cnblogs.com/Brambling/p/9263377.html
     *          https://blog.csdn.net/relaxyu/article/details/81735450
     *      a.B表里面的一个键是跟随A表的键值修改而修改的，B表里面的那个键叫外键，A表叫主表，B表叫从表，
     *      b.作用是保持数据的一致性,主表更新和删除，子表也会跟着变动
     *      c.主键是唯一能确定不一样的
     *      d.具体用法参考上面地址
     *      e.主表更新，子表也会跟着更新，如果主表删除，子表对应外键哪一行也会跟着删除，即级联删除、更新,从表插入在主表不存在的外键会报错
     *  34.为null对mysql索引的影响，空值和null区别
     *      a.空值和null区别:空值不占用空间，用 = <> != 来判断，而null是占用空间的，用is null或is not null判断
     *      b.null在计算数目或者sum等是不计算在内的
     *      c.null对mysql索引影响
     *          1.null需要占用额外空间
     *          2.null不走索引，且会使索引统计更加复杂一些
     *      d.最好把字段设置为不为null，设置默认值，字符串设为空值'',数字设为0
     *
     *  35.mysql事务(innodb),mysql的引擎中只有innodb支持事务
     *      参考：https://blog.csdn.net/w_linux/article/details/79666086、
     *      https://www.cnblogs.com/cjsblog/p/8365921.html
     *      a.4大特征(ACID)：
     *          原子性（A）:事务是最小单位，不可再分
     *          一致性（C）:所有的DML要么一起成功，要么一起失败
     *          隔离性（I）:事务之间具有隔离性
     *          持久性（D）:事务commit后能持久话到磁盘
     *      b.在事务进行过程中，未结束之前，DML语句是不会更改底层数据，只是将历史操作记录一下，在内存中完成记录。
     *          只有在事务结束的时候，而且是成功的结束的时候，才会修改底层硬盘文件中的数据
     *      c.隔离性（用于在并发事务执行的时候，如果串行的话，不用隔离）
     *          4个隔离级别
     *              1.读未提交（read uncommitted）
     *                  事务A未提交的数据，事务B可以读取到，此种方法会有脏数据
     *                  隔离级别最低，这种级别一般是在理论上存在，数据库隔离级别一般都高于该级别
     *              2.读已提交（read committed）
     *                  事务A提交了数据，事务才B可以读取到，此种方法没有脏数据，但会出现重复读取的时候，可能结果已经变了
     *              3.可重复读（repeatable read）
     *                  事务A和事务B，事务A提交之后的数据，事务B读取不到，不管A事务是否committed了，重复读取都是第一次，
     *                  对方提交之后的数据，我还是读取不到，不可重复读重点在于update和delete
     *                  但是会出现幻像读，就是读取到结果，出现新增，如范围查询，结果变多了
     *                  MySQL默认级别
     *              4.串行化（serializable）
     *                  事务A和事务B，事务A在操作数据库时，事务B只能排队等待
     *                  这种隔离级别很少使用，吞吐量太低，用户体验差
     *                  可以避免“幻像读”，每一次读取的都是数据库中真实存在数据，事务A与事务B串行，而不并发
     *                  幻读的重点在于insert
     *       d.mvcc(多版本并发控制)
     *       https://www.cnblogs.com/chinesern/p/7592537.html
     *       https://blog.csdn.net/w2064004678/article/details/83012387
     *          1.解决不可重复读
     *          2.每一行多了创建事务版本号和删除事务版本号
     *          3.过程
     *             insert-当前的A事务-create_version=1，delete_version=null
     *             update-新插入一行B事务-create_version=2,delete_version=null 同时A事务-delete_version=2
     *             delete 最新的一行C事务-create_version=2,delete_version=3
     *             select 如何查找出A事务的数据
     *                 a.创建版本小于等于当前版本 create_version <= 1，确保读取的行的是在当前事务版本之前的
     *                 b.删除版本大于等于当前版本 delete_version >=1,确保事务之前行没有被删除
     *
     *       e.快照读和当前读
     *          快照读：读取的是快照版本，也就是历史版本
     *          当前读：读取的是最新版本
     *          普通的SELECT就是快照,UPDATE、DELETE、INSERT、SELECT ...  LOCK IN SHARE MODE、SELECT ... FOR UPDATE是当前读
     *          Consistent read（一致性读）是READ COMMITTED和REPEATABLE READ隔离级别下普通SELECT语句默认的模式。
     *          一致性读不会给它所访问的表加任何形式的锁，因为都是读取快照版本，因此其它事务可以同时并发的修改它们
     *       f.锁
     *          Record Locks（记录锁）：在索引记录上加锁
     *          Gap Locks（间隙锁）：在索引记录之间加锁
     *          Next-Key Locks：在索引记录上加锁，并且在索引记录之前的间隙加锁
     *       g.总结
     *         1.利用MVCC实现一致性非锁定读，保证同一个事务中多次读取相同的数据返回的结果是一样的，解决了不可重复读的问题
     *         2.利用Gap Locks和Next-Key可以阻止其它事务在锁定区间内插入数据，因此解决了幻读问题
     *
     *  40.B-tree，B-plus-tree
     *      参考：https://www.cnblogs.com/vincently/p/4526560.html
     *      https://blog.csdn.net/bigtree_3721/article/details/73626663
     *      a.B-tree:升级版的二叉查找树，在二叉查找树的基础上，每个节点可以包含2个以上的key，且里面的key也是顺序的
     *      b.B-plus-tree:在B-tree的基础上
     *          1.非叶子节点只包含导航信息（子节点指针），不包含具体值，具体值保存在所有叶子节点，只有达到叶子结点才命中
     *          2.所有叶子节点是一颗从小到大的顺序链表，便于区间查找和遍历
     *          3.更适合文件索引系统，容纳的查询信息更多，因为磁盘的磁道先统一寻址，再找到具体的值
     *      c.B+树的优点
     *          1.非叶子节点不会带上ROWID，这样，一个块中可以容纳更多的索引项，一是可以降低树的高度。二是一个内部节点可以定位更多的叶子节点
     *          2.叶子节点之间通过指针来连接，范围扫描将十分简单，而对于B树来说，则需要在叶子节点和内部节点不停的往返移动
     *
     *  41.innodb索引
     *      索引：https://www.cnblogs.com/fuyunbiyi/p/2429297.html
     *      mysql中普遍使用B+Tree做索引
     *      聚簇索引：索引的叶节点就是数据节点。确定表中数据的物理顺序，一个表只能包含一个聚集索引
     *      非聚簇索引：叶节点仍然是索引节点，只不过有一个指针指向对应的数据块
     *
     *  49.MySQL存储引擎-InnoDB&MyISAM区别
     *  https://www.cnblogs.com/liqiangchn/p/9066686.html
     *      两者最大的区别就是InnoDB支持事务，和行锁，而MyISAM是不支持的
     *      1.InnoDB的数据存储基于聚簇索引（数据和索引是存在一起，主键索引就是，不过他的二级索引（非主键索引）必须包含主键列）的，
     *          而MyISAM是基于非聚簇索引进行存储的，索引和数据是分开的
     *      2.InnoDB支持事务，MyISAM不支持
     *      3.InnoDB支持行锁，MyISAM不支持
     *      4.MyisAM支持全文索引（FULLTEXT）、压缩索引，InnoDB不支持
     *      5.InnoDB关注事务和并发，MyISAM关注查询性能
     *
     *  50.Mysql中的各种锁以及死锁
     *  https://www.cnblogs.com/LBSer/p/5183300.html
     *      a.锁：
     *          1.表级锁（MyISAM）：读共享，写互斥
     *          2.页级锁（BDB）：锁定相邻的一组记录
     *          3.行级锁（InnoDB）：共享锁和排他锁，通过索引上的索引项来实现，意味者：只有通过索引条件操作数据，InnoDB才会使用行级锁，否则，InnoDB将使用表锁
     *          4.间隙锁（InnoDB）：防止幻读，锁定一定范围内的数据
     *          5.乐观锁：如mvcc不加锁，mvcc来解决不可重复读
     *          6.意向锁:用来解决行锁和表锁互斥的问题：在意向锁存在的情况下，事务A必须先申请表的意向锁，成功后再申请一行的行锁
     *              如事务A行读锁，事务B表锁，是互斥的，但是如果查找表里面哪一行是行锁，效率很低，于是有了意向锁
     *          7.mysql实现悲观锁和乐观锁
     *          https://www.cnblogs.com/zhiqian-ali/p/6200874.html
     *              a.悲观锁：select for update实现，里面用行锁实现的
     *              b.乐观锁：通过版本号或时间戳来实现，先select出版本号保存在内存，然后update版本号，将其+1，条件是数据库里面的版本号和
     *                  内存里面保存的是一样的，如果一样则获取到锁，否者失败，时间戳实现一样的道理
     *                  其实和cas差不多
     *
     *
     *      b.死锁
     *          1.场景:
     *              a.不同表相同记录行锁冲突:2个事务执行操作2张表，动作一模一样，但是顺序不一样，就和多线程出现死锁一样的场景
     *              b.相同表记录行锁冲突:2个事务执行操作2条数据，动作一模一样，但是顺序不一样，就和多线程出现死锁一样的场景
     *          2.如果避免：
     *              a.以固定的顺序访问表和行
     *              b.为表添加合理的索引。因为操作索引是会使用行锁
     *              c.大事务拆小。大事务更倾向于死锁，如果业务允许，将大事务拆小
     *          3.如何定位死锁成因
     *              a.通过应用业务日志定位到问题代码，找到相应的事务对应的sql
     *              b.确定数据库隔离级别,可以确定数据库的隔离级别，我们数据库的隔离级别是RC，这样可以很大概率排除gap锁造成死锁的嫌疑
     *              c.找DBA执行下show InnoDB STATUS看看最近死锁的日志
     *              d.mysql有机制去检查死锁
     *
     *  48.数据库3大范式规则
     *      1.第一范式：每列是不可在分割单元，且不能有重复
     *      2.第二范式：每列要有主键，相当于有主属性
     *      3.第三范式：每列的非主属性必须直接依赖于主属性，而不是间接依赖
     *
     *  53.MySQL数据库优化的几种方式
     *  https://blog.51cto.com/yangshufan/2168952?source=drh
     *  my sql如何优化查询
     *  后续再看下
     *
     *  54.覆盖索引：
     *  https://www.jianshu.com/p/77eaad62f974
     *      a.查询语句覆盖了索引时（查询结果和条件里面都只是索引），只通过索引而不用通过获取行数据就可以获取到结果
     *      b.select选择的字段中含有不在索引中的字段 ，即索引没有覆盖全部的列,不会选择覆盖索引查询
     *      c..where条件中不能含有对索引进行like的操作。不会选择覆盖索引查询
     *
     *  55为什么选用自增量作为主键索引:
     *  http://www.cainiaoxueyuan.com/sjk/4571.html
     *      a.innodb的主键索引是聚集索引，是一颗B-plus-tree，在新增数据的时候，插入的时候是自增的，数据可直接插入到树的最后即可，性能高
     *
     *  56.数据库范式和反范式区别和优缺点
     *      范式
     *          优点：
     *              a.范式化的数据库更新起来更加快
     *              b.很少的冗余数据
     *              c.范式化的表更小
     *          缺点：
     *              查询的时候经常需要很多的关联
     *      反范式
     *          优点：可以避免关联，因为所有的数据几乎都可以在一张表上显示
     *          缺点：表格内的冗余较多，删除数据时候会造成表有些有用的信息丢失
     *
     *  57.mysql的分区和分表、
     *  https://www.cnblogs.com/myvic/p/7711498.html
     *      1.一般大于1000万行就可以分表了
     *      2.分区：一个表的物理文件分为，索引文件，数据文件，表结构文件，分区就是把这些文件分成不同的小块
     *      3.分表：把表内容分成不同的表
     *
     *  71.如何保证mysql和redis，数据一致性，解决数据库与缓存双写的时候数据不一致的情况
     *  https://www.cnblogs.com/lingqin/p/10279393.html
     *      a.延时双删策略
     *          1.如果先更新数据库，再删缓存，会出更新成功，删除缓存失败，造成数据不一致
     *          2.先删redis，再更新mysql，会出现再删除后，另外请求过来，然后拿到了老数据
     *          3.解决上面的问题，先删除缓存，再更新mysql，sleep一段时间（等待另外一个请求读取到老数据，然后更新到缓存里面，返回给前端后），再删除缓存
     *      b.订阅mysql binlog增量消息（只要更新数据就会更新binlog） + mq如kafka + redis
     *          1.订阅mysql binlog增量消息 ，通过kafka发送给redis，然后更新
     *
     *  72.数据库水平切分和垂直切分
     *  https://uule.iteye.com/blog/2122627
     *  https://blog.csdn.net/5hongbing/article/details/78024897
     *      a.垂直切分：垂直一刀，根据不同的业务拆分到不同的数据库，或者比较大的数据单独放一个表
     *          优点：拆分简单，业务明确
     *          缺点.事务不好处理，过度切分导致系统复杂，存在性能问题
     *      b.水平拆分：水平一刀，分表操作，
     *          优点：事务处理比较简单，不会存在性能问题
     *          缺点：分表逻辑不好控制，数据迁移比较麻烦（可采用一致性hash算法），跨节点join，排序等等比较麻烦
     *          一般拆分到数据1000万
     *      c.数据切分应引发的问题
     *          1.分布式事务（垂直切分）
     *          2.跨节点Join的问题，排序等等问题
     *
     *  73.sql优化
     *      a.建立合适的字段
     *      b.建立合适的索引
     *      c.分库分表
     *      d.查询优化
     *      d.运维层面了
     *      .
     *  75.innodb下的count(*)和count（1）区别
     *  https://msd.misuland.com/pd/2884250068896976750
     *      1.高版本其实没有任务区别
     *      2.如果表里面索引只有主键，则走主键来统计条数
     *      3.如果表里面二级索引则会走二级索引来统计条数（占用磁盘空间比较小）
     *
     *  83.为什么组合索引是最左原则
     *  https://blog.csdn.net/weixin_41462047/article/details/80261546
     *      a.组合索引在b+树里面存储的结构和普通的索引是一样的
     *      b.其非叶子节点存储的是第一个关键字的索引，只是叶子节点保存的是联合索引的所有索引，然后按照声明的顺序保存的
     *
     *  87.为何mysql事务隔离级别默认是可重复读，而oracle的隔离级别是都已提交
     *  https://www.iteye.com/blog/pre-2438968
     *      因为mysql的主从复制里面binlog日志的原因，binlog模式，Statement：记录的是可能改变数据的SQL语句
     *      可能会导致主从复制的一致性问题
     *
     *  63.mysql集群主从复制，主从同步
     *      a.集群中每个节点都是全部内容
     *      b.master节点上面记录的binlog-记录了所有操作，从数据库启动一个io线程复制binlog到从
     c.通过binlog传到中继日志里面
     d.半同步，异步，同步
     *
     */
}
